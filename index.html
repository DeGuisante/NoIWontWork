<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>...</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Alumni+Sans:ital,wght@0,100..900;1,100..900&family=Bebas+Neue&family=Lobster&family=Tiny5&family=Waterfall&display=swap');
        * { 
            font-family: "Alumni Sans", sans-serif;
            font-optical-sizing: auto;
            font-weight: normal;
            font-style: normal;
            box-sizing: border-box;
        }
        body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        #render3d { z-index: 50; }
        #ui { z-index: 100; }
        #backgroundui { z-index: 0; }
        .layer {
            display: block;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        .shake-light {
            animation: shakeLight 0.4s ease-in-out infinite;
        }

        @keyframes shakeLight {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            20%      { transform: translate(-1px, 1px) rotate(-0.5deg); }
            40%      { transform: translate(1px, -1px) rotate(0.5deg); }
            60%      { transform: translate(-1px, -1px) rotate(0deg); }
            80%      { transform: translate(1px, 1px) rotate(-0.5deg); }
        }
        .shake-medium {
            animation: shakeMedium 0.3s ease-in-out infinite;
        }

        @keyframes shakeMedium {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10%      { transform: translate(-2px, -1px) rotate(-1deg); }
            30%      { transform: translate(2px, 2px) rotate(1deg); }
            50%      { transform: translate(-1px, 2px) rotate(-1.5deg); }
            70%      { transform: translate(2px, -2px) rotate(1deg); }
            90%      { transform: translate(-2px, 1px) rotate(-0.5deg); }
        }
        .shake-strong {
            animation: shakeStrong 0.2s linear infinite;
        }

        @keyframes shakeStrong {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10%      { transform: translate(-4px, -3px) rotate(-3deg); }
            20%      { transform: translate(3px, 4px) rotate(2deg); }
            30%      { transform: translate(-4px, 2px) rotate(-2.5deg); }
            40%      { transform: translate(3px, -4px) rotate(3deg); }
            50%      { transform: translate(-2px, -3px) rotate(-1deg); }
            60%      { transform: translate(4px, 3px) rotate(2.5deg); }
            70%      { transform: translate(-3px, 4px) rotate(-3deg); }
            80%      { transform: translate(4px, -3px) rotate(1.5deg); }
            90%      { transform: translate(-4px, -2px) rotate(-2deg); }
        }
    </style>
</head>
<body>
    <div id="ui" class="layer"></div>
    <canvas id="render3d" class="layer"></canvas>
    <div id="backgroundui" class="layer"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
            "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.3/dist/tween.esm.js",
            "rapier": "https://cdn.skypack.dev/@dimforge/rapier3d-compat"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import * as TWEEN from '@tweenjs/tween.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import RAPIER from 'rapier';

        const BASEURL = "https://raw.githubusercontent.com/DeGuisante/noiwontwork.github.io/refs/heads/master/data/"

        class ThreeObjectBuilder {
            #object
            constructor(object) {
                this.#object = object;
            }

            clone() {
                this.#object = this.#object.clone();
                return this;
            }

            setPosition(x, y, z) {
                this.#object.position.set(x, y, z);
                return this;
            }

            setRotation(x, y, z, order = 'XYZ') {
                this.#object.rotation.set(x, y, z, order);
                return this;
            }

            setScale(x, y, z = x) {
                this.#object.scale.set(x, y, z);
                return this;
            }

            setQuaternion(x, y, z, w) {
                this.#object.quaternion.set(x, y, z, w);
                return this;
            }

            lookAt(x, y, z) {
                this.#object.lookAt(x, y, z);
                return this;
            }

            setName(name) {
                this.#object.name = name;
                return this;
            }

            setVisible(visible) {
                this.#object.visible = visible;
                return this;
            }

            setShadow({ cast = true, receive = true } = {}) {
                this.#object.castShadow = cast;
                this.#object.receiveShadow = receive;
                return this;
            }

            addTo(parent) {
                parent.add(this.#object);
                return this;
            }

            getObject() {
                return this.#object;
            }
        }

        const randomBetween = (min, max) => {
            // Рандом между min ... max
            return min + Math.random() * (max - min);
        }

        const wrapAxis = (value, min, max) => {
            // Зацикливание значения вдоль координаты
            const range = max - min;
            if (range <= 0) {
                return min;
            }
            if (value < min) {
                return max - ((min - value) % range);
            }
            if (value > max) {
                return min + ((value - max) % range);
            }
            return value;
        }

        class LocationDustParticleSystem {
            static DEFAULT_LOCATION_DUST_SETTINGS = {
                enabled: true,
                count: 240,
                area: {
                    center: { x: 0, y: 1.8, z: 0 },
                    size: { x: 10.5, y: 4.5, z: 12 }
                },
                appearance: {
                    color: 0xcbb89f,
                    opacityMin: 0.08,
                    opacityMax: 0.28,
                    opacityMultiplier: 1,
                    sizeMultiplier: 1,
                    sizeMin: 0.025,
                    sizeMax: 0.07
                },
                motion: {
                    fallSpeedMin: 0.015,
                    fallSpeedMax: 0.045,
                    speedMultiplier: 1,
                    driftMultiplier: 1,
                    swayMultiplier: 1,
                    driftX: 0.03,
                    driftZ: 0.02,
                    swayAmplitudeX: 0.08,
                    swayAmplitudeZ: 0.06,
                    swayFrequencyMin: 0.25,
                    swayFrequencyMax: 0.8
                }
            };

            static createLocationDustSettings(overrides = {}) {
                return {
                    enabled: overrides.enabled ?? LocationDustParticleSystem.DEFAULT_LOCATION_DUST_SETTINGS.enabled,
                    count: overrides.count ?? LocationDustParticleSystem.DEFAULT_LOCATION_DUST_SETTINGS.count,
                    area: {
                        center: {
                            ...LocationDustParticleSystem.DEFAULT_LOCATION_DUST_SETTINGS.area.center,
                            ...(overrides.area?.center ?? {})
                        },
                        size: {
                            ...LocationDustParticleSystem.DEFAULT_LOCATION_DUST_SETTINGS.area.size,
                            ...(overrides.area?.size ?? {})
                        }
                    },
                    appearance: {
                        ...LocationDustParticleSystem.DEFAULT_LOCATION_DUST_SETTINGS.appearance,
                        ...(overrides.appearance ?? {})
                    },
                    motion: {
                        ...LocationDustParticleSystem.DEFAULT_LOCATION_DUST_SETTINGS.motion,
                        ...(overrides.motion ?? {})
                    }
                };
            }

            constructor(renderer, settings) {
                this.renderer = renderer;
                this.settings = settings;
                this.count = settings.count;
                this.areaMin = new THREE.Vector3(
                    settings.area.center.x - settings.area.size.x / 2,
                    settings.area.center.y - settings.area.size.y / 2,
                    settings.area.center.z - settings.area.size.z / 2
                );
                this.areaMax = new THREE.Vector3(
                    settings.area.center.x + settings.area.size.x / 2,
                    settings.area.center.y + settings.area.size.y / 2,
                    settings.area.center.z + settings.area.size.z / 2
                );

                this.positions = new Float32Array(this.count * 3);
                this.sizes = new Float32Array(this.count);
                this.alphas = new Float32Array(this.count);
                this.fallSpeeds = new Float32Array(this.count);
                this.driftX = new Float32Array(this.count);
                this.driftZ = new Float32Array(this.count);
                this.swayAmplitudeX = new Float32Array(this.count);
                this.swayAmplitudeZ = new Float32Array(this.count);
                this.swayFrequency = new Float32Array(this.count);
                this.swayPhase = new Float32Array(this.count);

                this.geometry = new THREE.BufferGeometry();
                this.animationState = {
                    opacity: settings.appearance.opacityMultiplier ?? 1,
                    size: settings.appearance.sizeMultiplier ?? 1,
                    speed: settings.motion.speedMultiplier ?? 1,
                    drift: settings.motion.driftMultiplier ?? 1,
                    sway: settings.motion.swayMultiplier ?? 1
                };
                this.material = new THREE.ShaderMaterial({
                    transparent: true,
                    depthWrite: false,
                    uniforms: {
                        uColor: { value: new THREE.Color(settings.appearance.color) },
                        uOpacityMultiplier: { value: this.animationState.opacity },
                        uSizeMultiplier: { value: this.animationState.size },
                        uScale: { value: renderer.domElement.clientHeight / 2 },
                        uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
                    },
                    vertexShader: `
                        attribute float aSize;
                        attribute float aAlpha;

                        uniform float uScale;
                        uniform float uPixelRatio;
                        uniform float uSizeMultiplier;

                        varying float vAlpha;

                        void main() {
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                            float pointSize = aSize * uScale * uPixelRatio * uSizeMultiplier / max(0.2, -mvPosition.z);
                            gl_PointSize = clamp(pointSize, 1.0, 16.0);
                            vAlpha = aAlpha;
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 uColor;
                        uniform float uOpacityMultiplier;

                        varying float vAlpha;

                        void main() {
                            float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
                            float alpha = smoothstep(0.5, 0.0, distanceToCenter) * vAlpha * uOpacityMultiplier;
                            if (alpha <= 0.01) {
                                discard;
                            }
                            gl_FragColor = vec4(uColor, alpha);
                        }
                    `
                });

                this.#fillParticles();

                this.geometry.setAttribute("position", new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute("aSize", new THREE.BufferAttribute(this.sizes, 1));
                this.geometry.setAttribute("aAlpha", new THREE.BufferAttribute(this.alphas, 1));

                this.object = new THREE.Points(this.geometry, this.material);
                this.object.frustumCulled = false;
                this.object.renderOrder = 2;
            }

            #fillParticles() {
                for (let i = 0; i < this.count; i++) {
                    this.#resetParticle(i, true);
                }
            }

            #resetParticle(index, randomY = false) {
                const stride = index * 3;
                const { appearance, motion } = this.settings;

                this.positions[stride] = randomBetween(this.areaMin.x, this.areaMax.x);
                this.positions[stride + 1] = randomY
                    ? randomBetween(this.areaMin.y, this.areaMax.y)
                    : this.areaMax.y;
                this.positions[stride + 2] = randomBetween(this.areaMin.z, this.areaMax.z);

                this.sizes[index] = randomBetween(appearance.sizeMin, appearance.sizeMax);
                this.alphas[index] = randomBetween(appearance.opacityMin, appearance.opacityMax);
                this.fallSpeeds[index] = randomBetween(motion.fallSpeedMin, motion.fallSpeedMax);
                this.driftX[index] = randomBetween(-motion.driftX, motion.driftX);
                this.driftZ[index] = randomBetween(-motion.driftZ, motion.driftZ);
                this.swayAmplitudeX[index] = randomBetween(0, motion.swayAmplitudeX);
                this.swayAmplitudeZ[index] = randomBetween(0, motion.swayAmplitudeZ);
                this.swayFrequency[index] = randomBetween(motion.swayFrequencyMin, motion.swayFrequencyMax);
                this.swayPhase[index] = Math.random() * Math.PI * 2;
            }

            update(delta) {
                this.#syncAnimationState();

                const speedMultiplier = Math.max(0, this.animationState.speed);
                const driftMultiplier = this.animationState.drift;
                const swayMultiplier = this.animationState.sway;

                for (let i = 0; i < this.count; i++) {
                    const stride = i * 3;
                    this.swayPhase[i] += this.swayFrequency[i] * delta * Math.max(0, swayMultiplier);

                    this.positions[stride] += (this.driftX[i] * driftMultiplier + Math.sin(this.swayPhase[i]) * this.swayAmplitudeX[i] * swayMultiplier) * delta;
                    this.positions[stride + 1] -= this.fallSpeeds[i] * speedMultiplier * delta;
                    this.positions[stride + 2] += (this.driftZ[i] * driftMultiplier + Math.cos(this.swayPhase[i] * 0.85) * this.swayAmplitudeZ[i] * swayMultiplier) * delta;

                    if (this.positions[stride + 1] < this.areaMin.y) {
                        this.#resetParticle(i, false);
                        continue;
                    }

                    this.positions[stride] = wrapAxis(this.positions[stride], this.areaMin.x, this.areaMax.x);
                    this.positions[stride + 2] = wrapAxis(this.positions[stride + 2], this.areaMin.z, this.areaMax.z);
                }

                this.geometry.attributes.position.needsUpdate = true;
            }

            #syncAnimationState() {
                const safeOpacity = THREE.MathUtils.clamp(this.animationState.opacity, 0, 1);
                const safeSize = Math.max(0, this.animationState.size);

                this.animationState.opacity = safeOpacity;
                this.animationState.size = safeSize;

                this.material.uniforms.uOpacityMultiplier.value = safeOpacity;
                this.material.uniforms.uSizeMultiplier.value = safeSize;
            }

            resize() {
                this.material.uniforms.uScale.value = this.renderer.domElement.clientHeight / 2;
                this.material.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
            }

            dispose() {
                this.geometry.dispose();
                this.material.dispose();
            }
        }

        class DobrodzeyDebugManager {
            constructor() {
                this._enabled = false;
                this.currentScene = undefined;
                this.currentPhysicsWorld = undefined;
                this.colliderMeshes = new Map();
                this.helpers = [];
                this.colliderMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.5
                });
            }

            get enabled() {
                return this._enabled;
            }

            set enabled(value) {
                this.setEnabled(value);
            }

            reset() {
                this.clearColliderMeshes();

                for (const helper of this.helpers) {
                    helper.scene.remove(helper.object);
                    if (helper.dispose) {
                        this.disposeObject(helper.object);
                    }
                }

                this.helpers = [];
                this.currentScene = undefined;
                this.currentPhysicsWorld = undefined;
            }

            attach(scene, physicsWorld) {
                this.currentScene = scene;
                this.currentPhysicsWorld = physicsWorld;
                this.syncHelpersVisibility();
            }

            setEnabled(enabled) {
                this._enabled = Boolean(enabled);
                if (!this._enabled) {
                    this.clearColliderMeshes();
                }
                this.syncHelpersVisibility();
            }

            registerHelper(scene, object, options = {}) {
                const { dispose = false } = options;
                scene.add(object);
                object.visible = this.enabled;
                this.helpers.push({ scene, object, dispose });
            }

            createParticleAreaHelper(area) {
                const boxGeometry = new THREE.BoxGeometry(area.size.x, area.size.y, area.size.z);
                const edgesGeometry = new THREE.EdgesGeometry(boxGeometry);
                boxGeometry.dispose();

                const material = new THREE.LineBasicMaterial({
                    color: 0x2f6bff,
                    transparent: true,
                    opacity: 0.9
                });

                const object = new THREE.LineSegments(edgesGeometry, material);
                object.position.set(area.center.x, area.center.y, area.center.z);
                object.frustumCulled = false;
                object.renderOrder = 3;
                return object;
            }

            update() {
                this.syncHelpersVisibility();
                this.updateColliders();
            }

            clearColliderMeshes() {
                if (this.currentScene) {
                    for (const mesh of this.colliderMeshes.values()) {
                        this.currentScene.remove(mesh);
                        this.disposeObject(mesh);
                    }
                }

                this.colliderMeshes.clear();
            }

            syncHelpersVisibility() {
                for (const { object } of this.helpers) {
                    object.visible = this.enabled;
                }
            }

            disposeObject(object) {
                if (!object) {
                    return;
                }

                if (object.geometry) {
                    object.geometry.dispose();
                }

                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach((material) => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }

                object.children?.forEach((child) => this.disposeObject(child));
            }

            createColliderMesh(collider) {
                const type = collider.shapeType();
                let mesh = null;

                if (type === RAPIER.ShapeType.Cuboid) {
                    const he = collider.halfExtents();
                    const geometry = new THREE.BoxGeometry(he.x * 2, he.y * 2, he.z * 2);
                    mesh = new THREE.Mesh(geometry, this.colliderMaterial.clone());
                }
                else if (type === RAPIER.ShapeType.Ball) {
                    const r = collider.radius();
                    const geometry = new THREE.SphereGeometry(r, 16, 16);
                    mesh = new THREE.Mesh(geometry, this.colliderMaterial.clone());
                }
                else if (type === RAPIER.ShapeType.Capsule) {
                    const r = collider.radius();
                    const halfHeight = collider.halfHeight();
                    const group = new THREE.Group();

                    const cylGeo = new THREE.CylinderGeometry(r, r, halfHeight * 2, 16);
                    const cylinder = new THREE.Mesh(cylGeo, this.colliderMaterial.clone());
                    group.add(cylinder);

                    const sphereGeo = new THREE.SphereGeometry(r, 16, 16);
                    const topSphere = new THREE.Mesh(sphereGeo, this.colliderMaterial.clone());
                    topSphere.position.y = halfHeight;
                    group.add(topSphere);

                    const bottomSphere = new THREE.Mesh(sphereGeo, this.colliderMaterial.clone());
                    bottomSphere.position.y = -halfHeight;
                    group.add(bottomSphere);

                    mesh = group;
                }
                else if (type === RAPIER.ShapeType.Cylinder) {
                    const r = collider.radius();
                    const halfHeight = collider.halfHeight();
                    const geometry = new THREE.CylinderGeometry(r, r, halfHeight * 2, 16);
                    mesh = new THREE.Mesh(geometry, this.colliderMaterial.clone());
                }
                else if (type === RAPIER.ShapeType.Cone) {
                    const r = collider.radius();
                    const halfHeight = collider.halfHeight();
                    const geometry = new THREE.ConeGeometry(r, halfHeight * 2, 16);
                    mesh = new THREE.Mesh(geometry, this.colliderMaterial.clone());
                }

                return mesh;
            }

            updateColliders() {
                if (!this.enabled || !this.currentScene || !this.currentPhysicsWorld) return;

                const currentColliders = new Set();

                this.currentPhysicsWorld.forEachCollider((collider) => {
                    currentColliders.add(collider);

                    let mesh = this.colliderMeshes.get(collider);
                    if (!mesh) {
                        mesh = this.createColliderMesh(collider);
                        if (mesh) {
                            this.currentScene.add(mesh);
                            this.colliderMeshes.set(collider, mesh);
                        }
                    }

                    if (!mesh) {
                        return;
                    }

                    const pos = collider.translation();
                    const rot = collider.rotation();
                    mesh.position.set(pos.x, pos.y, pos.z);
                    mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
                });

                for (const [collider, mesh] of this.colliderMeshes.entries()) {
                    if (!currentColliders.has(collider)) {
                        this.currentScene.remove(mesh);
                        this.disposeObject(mesh);
                        this.colliderMeshes.delete(collider);
                    }
                }
            }
        }

        class DobrodzeyEngine {
            constructor(ui, canvas, backgroundui) {
                /** @type {HTMLElement} */
                this.ui = ui;
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.backgroundui = backgroundui;

                this.clock = new THREE.Clock();

                this.currentScene = undefined;
                this.currentPhysicsWorld = undefined;
                this.currentCamera = undefined;
                this.currentComposer = undefined;

                this.currentUpdate = undefined;
                this.currentPhysicsUpdate = undefined;

                this.sceneGenerators = {};
                this.storage = {};

                this.linkedObjectsAndRigidBodies = [];
                this.debug = new DobrodzeyDebugManager();

                this.defaultmaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            }

            async init() {
                await RAPIER.init();
                this.renderer.setAnimationLoop(this.loop.bind(this));
            }

            addLinkedObject(object, rigidBody, resolve) {
                this.linkedObjectsAndRigidBodies.push({ object, rigidBody, resolve });
            }

            addSceneGenerator(name, generator) {
                this.sceneGenerators[name] = generator;
            }

            createComposer(scene, camera) {
                const composer = new EffectComposer(this.renderer);
                composer.addPass(new RenderPass(scene, camera));
                return composer;
            }

            syncLinkedObjects() {
                for (const { object, rigidBody, resolve } of this.linkedObjectsAndRigidBodies) {
                    if (resolve) {
                        resolve(object, rigidBody);
                    } else {
                        const position = rigidBody.translation();
                        const rotation = rigidBody.rotation();

                        object.position.set(position.x, position.y, position.z);
                        object.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
                    }
                }
            }

            #updateEventHandler(target, eventName, propName, handler) {
                if (this[propName]) {
                    target.removeEventListener(eventName, this[propName]);
                }

                this[propName] = this.wrapFunctionWithGameIfItIsNotNull(handler);

                if (this[propName]) {
                    target.addEventListener(eventName, this[propName]);
                }
            }

            generateScene(name) {
                const generator = this.sceneGenerators[name];
                if (generator) {
                    this.debug.reset();

                    this.renderer.toneMapping = THREE.NoToneMapping;
                    this.linkedObjectsAndRigidBodies = [];

                    const sceneData = generator(this);

                    this.currentScene = sceneData.scene;
                    this.currentPhysicsWorld = sceneData.physicsWorld;
                    this.currentCamera = sceneData.camera;
                    this.currentComposer = sceneData.composer;

                    this.currentUpdate = sceneData.update;
                    this.currentPhysicsUpdate = sceneData.physicsUpdate;
                    this.debug.attach(this.currentScene, this.currentPhysicsWorld);

                    this.#updateEventHandler(document, 'keyup', 'currentKeyup', sceneData.keyup);
                    this.#updateEventHandler(document, 'keydown', 'currentKeydown', sceneData.keydown);
                    this.#updateEventHandler(window, 'resize', 'currentResize', sceneData.resize);

                    this.currentResize?.();
                    sceneData.ready?.(this);
                }
            }

            clearUI() {
                this.ui.replaceChildren();
            }

            clearBackgroundUI() {
                this.backgroundui.replaceChildren();
            }

            wrapFunctionWithGameIfItIsNotNull(func) {
                return func ? (...args) => func(this, ...args) : undefined;
            }

            cameraResize() {
                if (this.currentCamera) {
                    this.currentCamera.aspect = this.renderer.domElement.clientWidth / this.renderer.domElement.clientHeight;
                    this.currentCamera.updateProjectionMatrix();
                }
            }

            renderResize() {
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.currentComposer?.setSize(this.renderer.domElement.clientWidth, this.renderer.domElement.clientHeight);
                this.renderer.setSize(this.renderer.domElement.clientWidth, this.renderer.domElement.clientHeight, false);
            }

            getBestLocale(supportedLocales = ['base']) {
                const browserLangs = navigator.languages?.length > 0
                    ? navigator.languages
                    : [navigator.language || navigator.userLanguage || 'en'];

                const normalizedBrowserLangs = browserLangs.map(lang => lang.replace(/_/g, '-').toLowerCase());

                const supportedMap = supportedLocales.map(locale => ({
                    original: locale,
                    normalized: locale.toLowerCase()
                }));

                for (const browserLang of normalizedBrowserLangs) {
                    for (const supported of supportedMap) {
                        if (supported.normalized === browserLang) {
                            return supported.original;
                        }
                    }
                }

                for (const browserLang of normalizedBrowserLangs) {
                    const langCode = browserLang.split('-')[0];
                    for (const supported of supportedMap) {
                        if (supported.normalized === langCode || supported.normalized.startsWith(langCode + '-')) {
                            return supported.original;
                        }
                    }
                }

                const baseLocale = supportedLocales.find(locale => locale === 'base');
                return baseLocale || supportedLocales[0] || 'base';
            }

            loop() {
                const delta = this.clock.getDelta() || 0.016;
                if (this.currentPhysicsWorld) {
                    this.currentPhysicsWorld.step();
                    this.currentPhysicsUpdate?.(this, delta);
                }
                this.currentUpdate?.(this, delta);
                this.debug.update();

                if (this.currentComposer) {
                    this.currentComposer.render();
                } else if (this.currentScene && this.currentCamera) {
                    this.renderer.render(this.currentScene, this.currentCamera);
                }
            }

            applyDefaultLightShadowSettings(light) {
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                light.shadow.camera.near = 1;
                light.shadow.camera.far = 1000;
                light.shadow.bias = -0.01;
            }

            applyDefaultObjectShadowSettings(object) {
                object.castShadow = true;
                object.receiveShadow = true;
            }

            createFixedCollider(physcisWorld, x, y, z, w, h, d) {
                const bodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(x, y, z);
                const colliderDesc = RAPIER.ColliderDesc.cuboid(w, h, d);
                const body = physcisWorld.createRigidBody(bodyDesc);
                physcisWorld.createCollider(colliderDesc, body);
            }

            createPlayerBody(physicsWorld, playerRadius, playerHeight, x, y, z) {
                const playerBodyDesc = RAPIER.RigidBodyDesc.kinematicPositionBased().setTranslation(x, y, z);
                const playerBody = physicsWorld.createRigidBody(playerBodyDesc);
                const playerColliderDesc = RAPIER.ColliderDesc.capsule(playerHeight / 2, playerRadius);
                const playerCollider = physicsWorld.createCollider(playerColliderDesc, playerBody);

                const characterController = physicsWorld.createCharacterController(0.01);
                characterController.setApplyImpulsesToDynamicBodies(true);
                characterController.setSlideEnabled(true);
                characterController.enableAutostep(0.3, 0.1, false);
                characterController.setMaxSlopeClimbAngle(45 * (Math.PI / 180));

                return { characterController, playerBody, playerCollider };
            }
        }

        const game = new DobrodzeyEngine (
            document.querySelector("#ui"),
            document.querySelector("#render3d"),
            document.querySelector("#backgroundui")
        );

        (async () => {
            await game.init();

            // тестовая сцена со всеми типами коллайдеров
            game.addSceneGenerator("test", (game) => {
                game.clearUI();
                game.clearBackgroundUI();

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111122);

                const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                camera.position.set(8, 6, 12);
                camera.lookAt(0, 3, 0);

                const ambientLight = new THREE.AmbientLight(0x404060);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(2, 8, 4);
                scene.add(dirLight);
                const fillLight = new THREE.PointLight(0x446688, 0.5);
                fillLight.position.set(-3, 5, 5);
                scene.add(fillLight);

                const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
                scene.add(gridHelper);

                const gravity = { x: 0.0, y: -9.81, z: 0.0 };
                const physicsWorld = new RAPIER.World(gravity);

                const groundSize = 20.0;
                const groundHeight = 0.5;
                const groundBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0.0, -groundHeight/2, 0.0);
                const groundBody = physicsWorld.createRigidBody(groundBodyDesc);
                const groundColliderDesc = RAPIER.ColliderDesc.cuboid(groundSize/2, groundHeight/2, groundSize/2);
                physicsWorld.createCollider(groundColliderDesc, groundBody);

                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x336633 });
                const groundMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(groundSize, groundHeight, groundSize),
                    groundMaterial
                );
                groundMesh.position.set(0, -groundHeight/2, 0);
                scene.add(groundMesh);

                function createPhysicalObject(type, pos, color, sizeParams) {
                    let bodyDesc, colliderDesc, mesh;
                    
                    switch (type) {
                        case 'cuboid':
                            bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
                            colliderDesc = RAPIER.ColliderDesc.cuboid(sizeParams.w/2, sizeParams.h/2, sizeParams.d/2).setDensity(1.0);
                            mesh = new THREE.Mesh(new THREE.BoxGeometry(sizeParams.w, sizeParams.h, sizeParams.d), new THREE.MeshStandardMaterial({ color }));
                            break;
                        case 'ball':
                            bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
                            colliderDesc = RAPIER.ColliderDesc.ball(sizeParams.r).setDensity(1.0);
                            mesh = new THREE.Mesh(new THREE.SphereGeometry(sizeParams.r, 32, 16), new THREE.MeshStandardMaterial({ color }));
                            break;
                        case 'capsule':
                            bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
                            colliderDesc = RAPIER.ColliderDesc.capsule(sizeParams.halfHeight, sizeParams.r).setDensity(1.0);
                            const group = new THREE.Group();
                            const cylGeo = new THREE.CylinderGeometry(sizeParams.r, sizeParams.r, sizeParams.halfHeight*2, 16);
                            const cylMat = new THREE.MeshStandardMaterial({ color });
                            const cylinder = new THREE.Mesh(cylGeo, cylMat);
                            cylinder.position.y = 0;
                            group.add(cylinder);
                            const sphereGeo = new THREE.SphereGeometry(sizeParams.r, 16, 16);
                            const sphereMat = new THREE.MeshStandardMaterial({ color });
                            const topSphere = new THREE.Mesh(sphereGeo, sphereMat);
                            topSphere.position.y = sizeParams.halfHeight;
                            group.add(topSphere);
                            const bottomSphere = new THREE.Mesh(sphereGeo, sphereMat.clone());
                            bottomSphere.position.y = -sizeParams.halfHeight;
                            group.add(bottomSphere);
                            mesh = group;
                            break;
                        case 'cylinder':
                            bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
                            colliderDesc = RAPIER.ColliderDesc.cylinder(sizeParams.halfHeight, sizeParams.r).setDensity(1.0);
                            mesh = new THREE.Mesh(new THREE.CylinderGeometry(sizeParams.r, sizeParams.r, sizeParams.halfHeight*2, 16), new THREE.MeshStandardMaterial({ color }));
                            break;
                        case 'cone':
                            bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
                            colliderDesc = RAPIER.ColliderDesc.cone(sizeParams.halfHeight, sizeParams.r).setDensity(1.0);
                            mesh = new THREE.Mesh(new THREE.ConeGeometry(sizeParams.r, sizeParams.halfHeight*2, 16), new THREE.MeshStandardMaterial({ color }));
                            break;
                        default:
                            return null;
                    }

                    const body = physicsWorld.createRigidBody(bodyDesc);
                    physicsWorld.createCollider(colliderDesc, body);
                    
                    mesh.position.copy(pos);
                    scene.add(mesh);
                    game.addLinkedObject(mesh, body);
                }

                createPhysicalObject('cuboid', new THREE.Vector3(-6, 4, 0), 0xff5555, { w: 1.2, h: 1.2, d: 1.2 });
                createPhysicalObject('ball', new THREE.Vector3(-3, 5, 1), 0x55ff55, { r: 0.8 });
                createPhysicalObject('capsule', new THREE.Vector3(0, 6, -1), 0x5555ff, { halfHeight: 0.8, r: 0.5 });
                createPhysicalObject('cylinder', new THREE.Vector3(3, 4, 1), 0xffaa00, { halfHeight: 0.8, r: 0.6 });
                createPhysicalObject('cone', new THREE.Vector3(6, 5, -1), 0xaa44ff, { halfHeight: 1.0, r: 0.7 });

                createPhysicalObject('cuboid', new THREE.Vector3(-5, 2, 3), 0xff8888, { w: 0.8, h: 0.8, d: 0.8 });
                createPhysicalObject('ball', new THREE.Vector3(-2, 3, 4), 0x88ff88, { r: 0.6 });
                createPhysicalObject('capsule', new THREE.Vector3(2, 4, 3), 0x8888ff, { halfHeight: 0.6, r: 0.4 });
                createPhysicalObject('cylinder', new THREE.Vector3(5, 3, 4), 0xffcc88, { halfHeight: 0.6, r: 0.5 });
                createPhysicalObject('cone', new THREE.Vector3(7, 4, 2), 0xcc88ff, { halfHeight: 0.8, r: 0.5 });

                const physicsUpdate = (game, delta) => {
                    game.syncLinkedObjects();
                };

                const resize = (game) => {
                    game.cameraResize();
                    game.renderResize();
                };

                return {
                    scene,
                    camera,
                    physicsWorld,
                    physicsUpdate,
                    resize
                };
            });

            game.addSceneGenerator("loadingscreen", /** @param {DobrodzeyEngine} game */ (game) => {
                game.clearUI();
                game.clearBackgroundUI();

                game.ui.innerHTML = `
                    <div class="layer" style="background-color: black; pointer-events: none;"></div>
                    <div class="layer" id="loadingscreen-background" style="background-color: #385aac; pointer-events: none;">
                        <div style="position: fixed; transform: translate(0%, -100%); top: 100%; left: 20px;">
                            <div class="shake-light" id="loadingscreen-text" style="color: white; font-size: min(10vw, 10vh);">...</div>
                        </div>
                    </div>
                `;

                const loadingscreenBackground = document.querySelector("#loadingscreen-background");
                const loadingscreenText = document.querySelector("#loadingscreen-text");

                const fileLoader = new THREE.FileLoader();
                fileLoader.setResponseType("json");
                
                fileLoader.load(BASEURL + "textdata.json", data => {
                    game.storage.assets = {};
                    game.storage.strings = {};
                    
                    for (const key in data.strings)
                        game.storage.strings[key] = data.strings[key][game.getBestLocale(Object.keys(data.strings[key]))];

                    document.title = game.storage.strings.title;
                    const loadingString = game.storage.strings.loading;
                    loadingscreenText.textContent = loadingString;

                    const manager = new THREE.LoadingManager();

                    manager.onProgress = (item, loaded, total) => {
                        loadingscreenText.textContent = `${loadingString} ${Math.floor(loaded / total * 100)}%`;
                    }

                    for (const key in data.gameassets) {
                        const assetdata = data.gameassets[key]
                        switch (assetdata.type) {
                            case 0: // TextureLoader
                                new THREE.TextureLoader(manager).load(BASEURL + assetdata.path, data => { game.storage.assets[key] = data; });
                                break;
                            case 1: // GLTFLoader
                                new GLTFLoader(manager).load(BASEURL + assetdata.path, data => {
                                    data.scene.traverse((node) => {
                                        if (node.isMesh)
                                            game.applyDefaultObjectShadowSettings(node);
                                    });
                                    game.storage.assets[key] = data;
                                });
                                break;
                            case 2: // ImageLoader
                                new THREE.ImageLoader(manager).load(BASEURL + assetdata.path, data => { game.storage.assets[key] = data; });
                                break;
                        }
                    }

                    manager.onLoad = () => {
                        loadingscreenBackground.animate([{ clipPath: 'circle(200% at 10% 95%)'}, {clipPath: 'circle(0% at 10% 95%)' }], { duration: 1000, easing: 'ease-in-out', fill: 'forwards' }).onfinish = () => {
                            game.generateScene("maingame");
                        };
                    };
                });

                return {};
            });

            game.addSceneGenerator("maingame", /** @param {DobrodzeyEngine} game */ (game) => {
                game.clearUI();
                game.clearBackgroundUI();

                game.renderer.toneMapping = THREE.ReinhardToneMapping;

                game.storage.maingame ??= {};
                game.storage.maingame.input ??= {};
                game.storage.maingame.effects ??= {};
                game.storage.maingame.ispaused = false;
                game.storage.maingame.isactuallypaused = false;

                const scene = new THREE.Scene();

                const gravity = { x: 0.0, y: -9.81, z: 0.0 };
                const physicsWorld = new RAPIER.World(gravity);

                const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 100);

                game.storage.maingame.controls = new PointerLockControls(camera, game.renderer.domElement);
                const composer = game.createComposer(scene, camera);
                const ssaoPass = new SSAOPass( scene, camera, game.renderer.domElement.clientWidth, game.renderer.domElement.clientHeight );
                ssaoPass.kernelRadius = 8;
                ssaoPass.minDistance = 0.001;
                ssaoPass.maxDistance = 0.05;
                composer.addPass( ssaoPass );

                composer.addPass(new UnrealBloomPass( 
					new THREE.Vector2( game.renderer.domElement.clientWidth, game.renderer.domElement.clientHeight ),
					1.5, // strength - сила свечения
					0.4, // radius - радиус свечения
					0.85 // threshold - порог. Пиксели ярче этого значения будут светиться. 1.0 = только самые яркие
				));

                composer.addPass( new OutputPass() );

                // ==== РАЗМЕЩЕНИЕ ОБЪЕКТОВ НА СЦЕНЕ

                // ==== КОЛЛАЙДЕРЫ
                game.createFixedCollider(physicsWorld, 0, 0, 0, 10, 0, 10);
                game.createFixedCollider(physicsWorld, -1.4, 2, -2.21, 3, 2, 0);
                game.createFixedCollider(physicsWorld, 0, 2, -5.89, 4, 2, 0);
                game.createFixedCollider(physicsWorld, -3.7, 2, -5.89, 0, 2, 4);
                game.createFixedCollider(physicsWorld, 3.4, 2, -2, 0, 2, 4);
                game.createFixedCollider(physicsWorld, 3.6, 2, -4.85, 0.9, 2, 0.8);
                game.createFixedCollider(physicsWorld, -3, 2, -2.65, 0.6, 2, 0.6);

                // ==== ЛОКАЦИЯ

                scene.add(game.storage.assets.location.scene);

                scene.add(new ThreeObjectBuilder(game.storage.assets.fridge.scene).clone().setPosition(-3.1, 0, -2.85).setRotation(0, Math.PI/2, 0).getObject());
                scene.add(new ThreeObjectBuilder(game.storage.assets.fridge.scene).clone().setPosition(2.7, 0, 5.8).setRotation(0, Math.PI, 0).getObject());

                game.storage.maingame.effects.dust?.dispose?.();

                const dustSettings = LocationDustParticleSystem.createLocationDustSettings(game.storage.maingame.dustSettings);

                if (dustSettings.enabled) {
                    game.storage.maingame.effects.dust = new LocationDustParticleSystem(game.renderer, dustSettings);
                    scene.add(game.storage.maingame.effects.dust.object);
                    game.debug.registerHelper(scene, game.debug.createParticleAreaHelper(dustSettings.area), { dispose: true });
                } else {
                    game.storage.maingame.effects.dust = undefined;
                }

                const light = new THREE.PointLight( 0xffffff, 5, 100 );
                light.position.set( 0, 0.5, 0 );
                light.castShadow = true;
                game.applyDefaultLightShadowSettings(light);
                camera.add(light);
                
                const playerSize = 0.75;
                const { characterController, playerBody, playerCollider } = game.createPlayerBody(physicsWorld, playerSize/2, playerSize, 0, playerSize, -4);

                game.addLinkedObject(camera, playerBody, (object, rigidBody) => {
                    const position = rigidBody.translation();
                    const rotation = rigidBody.rotation();

                    object.position.set(position.x, position.y + playerSize, position.z);
                });
                scene.add(camera);
                
                const keydown = (game, event) => {
                    switch (event.code) {
                        case 'KeyW': game.storage.maingame.input.forward = true; event.preventDefault(); break;
                        case 'KeyS': game.storage.maingame.input.backward = true; event.preventDefault(); break;
                        case 'KeyA': game.storage.maingame.input.left = true; event.preventDefault(); break;
                        case 'KeyD': game.storage.maingame.input.right = true; event.preventDefault(); break;
                        default: break;
                    }
                };

                const keyup = (game, event) => {
                    switch (event.code) {
                        case 'KeyW': game.storage.maingame.input.forward = false; event.preventDefault(); break;
                        case 'KeyS': game.storage.maingame.input.backward = false; event.preventDefault(); break;
                        case 'KeyA': game.storage.maingame.input.left = false; event.preventDefault(); break;
                        case 'KeyD': game.storage.maingame.input.right = false; event.preventDefault(); break;
                        case 'Escape': game.storage.maingame.controls.lock(); event.preventDefault(); break;
                        default: break;
                    }
                };

                const update = /** @param {DobrodzeyEngine} game */ (game, delta) => {
                    game.storage.maingame.effects.dust?.update(delta);
                };

                const physicsUpdate = (game, delta) => {
                    const forward = new THREE.Vector3();
                    game.currentCamera.getWorldDirection(forward);
                    forward.y = 0;
                    forward.normalize().multiplyScalar(5);
                    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(5);

                    const direction = new THREE.Vector3();
                    //const upVector = new THREE.Vector3(0, 1, 0)
                    if (game.storage.maingame.input.forward) {
                        direction.add(forward);
                    }
                    if (game.storage.maingame.input.backward) {
                        direction.add(forward.negate());
                    }
                    if (game.storage.maingame.input.right) {
                        direction.add(right);

                    }
                    if (game.storage.maingame.input.left) {
                        direction.add(right.negate());
                    }

                    direction.y = game.currentPhysicsWorld.gravity.y;

                    direction.multiplyScalar(delta);

                    characterController.computeColliderMovement(playerCollider, direction);
                    const computedMovement = characterController.computedMovement();

                    const currentPos = playerBody.translation();
                    const nextPos = {
                        x: currentPos.x + computedMovement.x,
                        y: currentPos.y + computedMovement.y,
                        z: currentPos.z + computedMovement.z
                    };
                    playerBody.setNextKinematicTranslation(nextPos);

                    game.syncLinkedObjects();
                };

                const resize = (game) => {
                    game.cameraResize();
                    game.renderResize();
                    game.storage.maingame.effects.dust?.resize();
                };

                return {
                    scene,
                    camera,
                    composer,
                    physicsWorld,
                    update,
                    physicsUpdate,
                    keyup,
                    keydown,
                    resize
                };

            });
            
            game.generateScene("loadingscreen");
        })();
    </script>
</body>
</html>
